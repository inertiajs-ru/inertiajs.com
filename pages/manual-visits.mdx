import dedent from 'dedent-js'
import Layout from '../components/Layout'
import Notice from '../components/Notice'
import TabbedCodeExamples from '../components/TabbedCodeExamples'

export default Layout
export const meta = {
  title: 'Посещения вручную',
  links: [
    { url: '#метод', name: 'Метод' },
    { url: '#данные', name: 'Данные' },
    { url: '#история-браузера', name: 'История браузера' },
    { url: '#состояние-компонента', name: 'Состояние компонента' },
    { url: '#сохранение-прокрутки', name: 'Сохранение прокрутки' },
    { url: '#частичные-перезагрузки', name: 'Частичные перезагрузки' },
    { url: '#пользовательские-заголовки', name: 'Пользовательские заголовки' },
    { url: '#отмена-посещения', name: 'Отмена посещения' },
    { url: '#обратные-вызовы-событий', name: 'Обратные вызовы событий' },
    { url: '#устаревание-промиса', name: 'Устаревание промиса' },
  ],
}

# Посещения вручную

Помимо [создания ссылок](/links), также можно вручную делать инерционные посещения. Это делается с помощью метода `Inertia.visit()`.

<TabbedCodeExamples
  examples={[
    {
      name: 'Vue.js',
      language: 'js',
      code: dedent`
        // import { Inertia } from '@inertiajs/inertia'\n
        this.$inertia.visit(url, {
          method: 'get',
          data: {},
          replace: false,
          preserveState: false,
          preserveScroll: false,
          only: [],
          headers: {},
          onCancelToken: cancelToken => {},
          onCancel: () => {},
          onStart: visit => {},
          onProgress: progress => {},
          onSuccess: page => {},
          onFinish: () => {},
        })
      `,
    },
    {
      name: 'React',
      language: 'js',
      code: dedent`
        import { Inertia } from '@inertiajs/inertia'\n
        Inertia.visit(url, {
          method: 'get',
          data: {},
          replace: false,
          preserveState: false,
          preserveScroll: false,
          only: [],
          headers: {},
          onCancelToken: cancelToken => {},
          onCancel: () => {},
          onStart: visit => {},
          onProgress: progress => {},
          onSuccess: page => {},
          onFinish: () => {},
        })
      `,
    },
    {
      name: 'Svelte',
      language: 'js',
      code: dedent`
        import { Inertia } from '@inertiajs/inertia'\n
        Inertia.visit(url, {
          method: 'get',
          data: {},
          replace: false,
          preserveState: false,
          preserveScroll: false,
          only: [],
          headers: {},
          onCancelToken: cancelToken => {},
          onCancel: () => {},
          onStart: visit => {},
          onProgress: progress => {},
          onSuccess: page => {},
          onFinish: () => {},
        })
      `,
    },
  ]}
/>

Однако обычно вместо этого рекомендуется использовать один из методов быстрого доступа. Эти методы имеют те же параметры, что и `Inertia.visit()`.

<TabbedCodeExamples
  examples={[
    {
      name: 'Vue.js',
      language: 'js',
      code: dedent`
        // import { Inertia } from '@inertiajs/inertia'\n
        this.$inertia.get(url, data, options)
        this.$inertia.post(url, data, options)
        this.$inertia.put(url, data, options)
        this.$inertia.patch(url, data, options)
        this.$inertia.delete(url, options)
        this.$inertia.replace(url, options)
        this.$inertia.reload(options) // Uses the current URL
      `,
    },
    {
      name: 'React',
      language: 'js',
      code: dedent`
        import { Inertia } from '@inertiajs/inertia'\n
        Inertia.get(url, data, options)
        Inertia.post(url, data, options)
        Inertia.put(url, data, options)
        Inertia.patch(url, data, options)
        Inertia.delete(url, options)
        Inertia.replace(url, options)
        Inertia.reload(options) // Uses the current URL
      `,
    },
    {
      name: 'Svelte',
      language: 'js',
      code: dedent`
        import { Inertia } from '@inertiajs/inertia'\n
        Inertia.get(url, data, options)
        Inertia.post(url, data, options)
        Inertia.put(url, data, options)
        Inertia.patch(url, data, options)
        Inertia.delete(url, options)
        Inertia.replace(url, options)
        Inertia.reload(options) // Uses the current URL
      `,
    },
  ]}
/>

## Метод

Используйте опцию `method`, чтобы установить метод запроса на `get`, `post`, `put`, `patch` или `delete`. По умолчанию это `get`.

```js
Inertia.visit(url, { method: 'post' })
```

## Данные

Используйте опцию `data`, чтобы добавить данные в запрос.

```js
Inertia.visit('/users', {
  method: 'post',
  data: {
    name: 'John Doe',
    email: 'john.doe@example.com',
  },
})
```

Для удобства все методы `get()`, `post()`, `put()` и `patch()` включают в качестве второго аргумента значение `data`.

```js
Inertia.post('/users', {
  name: 'John Doe',
  email: 'john.doe@example.com',
})
```

## История браузера

При посещении Inertia автоматически добавляет новую запись в историю браузера. Однако также можно заменить текущую запись в истории, установив для параметра `replace` значение `true`.

```js
Inertia.get('/users', { search: 'John' }, { replace: true })
```

В качестве ярлыка Вы можете использовать метод `replace()`, чтобы сделать это автоматически.

```js
Inertia.replace('/users', { search: 'John' })
```

<Notice>
  Обратите внимание, что посещения одного и того же URL (включая строки запроса) автоматически устанавливают для <inlineCode>replace</inlineCode> значение{' '} <inlineCode>true</inlineCode>.
</Notice>

## Состояние компонента

По умолчанию при посещении той же страницы принудительно создается новый экземпляр компонента страницы, который очищает любое локальное состояние, такое как входные данные формы, положения прокрутки и состояния фокуса.

В определенных ситуациях необходимо сохранить состояние компонента страницы. Например, при отправке формы Вам необходимо сохранить данные формы на тот случай, если ошибки проверки вернутся.

Это можно сделать, установив для параметра `preserveState` значение `true`.

```js
Inertia.get('/users', { search: 'John' }, { preserveState: true })
```

Для удобства методы `post()`, `put()`, `patch()` и `replace()` автоматически устанавливают для параметра `preserveState` знаечние `true`.

## Сохранение прокрутки

При переходе между страницами Inertia имитирует поведение браузера по умолчанию, автоматически сбрасывая положение прокрутки тела документа (а также любые определенные Вами [области прокрутки](/scroll-management#области-прокрутки)) обратно наверх. Используйте опцию `preserveScroll`, чтобы отключить это поведение.

```js
Inertia.visit(url, { preserveScroll: true })
```

Для получения дополнительной информации смотрите страницу [управление прокруткой](/scroll-management).

## Частичные перезагрузки

Опция `only` позволяет Вам запрашивать подмножество свойств (данных) с сервера при последующих посещениях той же страницы.

```js
Inertia.visit('/users', { search: 'John' }, { only: ['users'] })
```

Для получения дополнительной информации смотрите страницу [частичные перезагрузки](/partial-reloads).

## Пользовательские заголовки

Опция `headers` позволяет Вам добавлять в запрос собственные заголовки.

```js
Inertia.post('/users', data, {
  headers: {
    'Custom-Header': 'value',
  },
})
```

<Notice>Заголовки Inertia имеют приоритет и поэтому не могут быть перезаписаны.</Notice>

## Отмена посещения

Вы можете отменить посещение, используя токен отмены, который Inertia автоматически генерирует и предоставляет с помощью обратного вызова `onCancelToken()` до совершения посещения.

```js
Inertia.post('/users', data, {
  onCancelToken: cancelToken => (this.cancelToken = cancelToken),
})

// Cancel the visit
this.cancelToken.cancel()
```

Когда визит отменяется, будут вызваны как обратные вызовы событий `onCancel()`, так и `onFinish()`.

## Обратные вызовы событий

В дополнение к [глобальным событиям](/events), Inertia также предоставляет ряд обратных вызовов событий для каждого посещения.

```js
Inertia.post('/users', data, {
  onStart: visit => {},
  onProgress: progress => {},
  onSuccess: page => {},
  onCancel: () => {},
  onFinish: () => {},
})
```

Возврат `false` из обратного вызова `onStart()` приведет к отмене посещения.

```js
Inertia.delete(`/users/${user.id}`, {
  onStart: () => confirm('Are you sure you want to delete this user?'),
})
```

Также возможно вернуть обещание из обратного вызова `onSuccess()`. Это задержит событие «finish» до тех пор, пока обещание не будет выполнено.

```js
Inertia.post(url, {
  onSuccess: () => {
    return Promise.all([
      this.doThing(),
      this.doAnotherThing()
    ])
  }
  onFinish: () => {
    // This won't be called until doThing()
    // and doAnotherThing() have finished.
  },
})
```

## Устаревание промиса

Начиная с `v0.3.0`, Inertia исключила промис, возвращаемый из `Inertia.visit()`. Если Вы вызовете `then()`, `catch()` или `finally()` во время посещения Inertia, Вы получите следующее предупреждение консоли:

<div class="py-4 px-6 border-l-4 border-orange-300 bg-orange-100 text-orange-900 text-sm font-mono">
  <div>
    Обещания посещения Inertia.js устарели и будут удалены в следующем выпуске. Вместо этого используйте новые обратные вызовы событий посещения.
  </div>
  <div class="mt-4">Узнайте больше на https://inertiajs.com/manual-visits#promise-deprecation</div>
</div>

Предпочтительный подход - использовать вместо этого новые [обратные вызовы событий](#обратные-вызовы-событий). Например, вместо использования `then()` используйте обратный вызов `onSuccess()`.

```js
Inertia.post('/profile', data, {
  onSuccess: () => {
    // Handle success event
  },
})
```

Вместо использования `finally()` используйте обратный вызов `onFinish()`.

```js
Inertia.post('/profile', data, {
  onFinish: () => {
    // Handle finish event
  },
})
```

И вместо использования `catch()` эти неожиданные ошибки лучше обрабатывать с помощью глобального обработчика событий ошибок.

```js
Inertia.on('error', event => {
  event.preventDefault()
  // Handle the error yourself
})
```
