import dedent from 'dedent-js'
import Layout from '../components/Layout'
import TabbedCodeExamples from '../components/TabbedCodeExamples'

export default Layout
export const meta = {
  title: 'Формы',
  links: [
    { url: '#отправка-форм', name: 'Отправка форм' },
    { url: '#загрузка-файлов', name: 'Загрузка файлов' },
    { url: '#помощник-формы', name: 'Помощник формы' },
    { url: '#проверка-на-стороне-сервера', name: 'Проверка на стороне сервера' },
    { url: '#классическая-отправка-xhr', name: 'Классическая отправка XHR' },
  ],
}

# Формы

## Отправка форм

Хотя с помощью Inertia можно отправлять классические формы, это не рекомендуется, так как они вызывают полную перезагрузку страницы. Вместо этого лучше перехватить отправленные формы, а затем сделать [запрос](/requests) с помощью Inertia.

<TabbedCodeExamples
  examples={[
    {
      name: 'Vue.js',
      language: 'twig',
      code: dedent`
        <template>
          <form @submit.prevent="submit">
            <label for="first_name">First name:</label>
            <input id="first_name" v-model="form.first_name" />
            <label for="last_name">Last name:</label>
            <input id="last_name" v-model="form.last_name" />
            <label for="email">Email:</label>
            <input id="email" v-model="form.email" />
            <button type="submit">Submit</button>
          </form>
        </template>\n
        <script>
        export default {
          data() {
            return {
              form: {
                first_name: null,
                last_name: null,
                email: null,
              },
            }
          },
          methods: {
            submit() {
              this.$inertia.post('/users', this.form)
            },
          },
        }
        </script>
      `,
    },
    {
      name: 'React',
      language: 'jsx',
      code: dedent`
        import { Inertia } from '@inertiajs/inertia'
        import React, { useState } from 'react'\n
        export default function Edit() {
          const [values, setValues] = useState({
            first_name: "",
            last_name: "",
            email: "",
          })\n
          function handleChange(e) {
            const key = e.target.id;
            const value = e.target.value
            setValues(values => ({
                ...values,
                [key]: value,
            }))
          }\n
          function handleSubmit(e) {
            e.preventDefault()
            Inertia.post('/users', values)
          }\n
          return (
            <form onSubmit={handleSubmit}>
              <label htmlFor="first_name">First name:</label>
              <input id="first_name" value={values.first_name} onChange={handleChange} />
              <label htmlFor="last_name">Last name:</label>
              <input id="last_name" value={values.last_name} onChange={handleChange} />
              <label htmlFor="email">Email:</label>
              <input id="email" value={values.email} onChange={handleChange} />
              <button type="submit">Submit</button>
            </form>
          )
        }
      `,
    },
    {
      name: 'Svelte',
      language: 'html',
      code: dedent`
        <script>
          import { Inertia } from '@inertiajs/inertia'\n
          let values = {
            first_name: null,
            last_name: null,
            email: null,
          }\n
          function handleSubmit() {
            Inertia.post('/users', values)
          }
        </script>\n
        <form on:submit|preventDefault={handleSubmit}>
          <label for="first_name">First name:</label>
          <input id="first_name" bind:value={values.first_name}>\n
          <label for="last_name">Last name:</label>
          <input id="last_name" bind:value={values.last_name}>\n
          <label for="email">Email:</label>
          <input id="email" bind:value={values.email}>\n
          <button type="submit">Submit</button>
        </form>
      `,
    },
  ]}
/>

В отличие от классической формы отправки ajax, с помощью Inertia Вы не обрабатываете поведение отправки сообщения на стороне клиента. Скорее, Вы делаете это на стороне сервера, используя [перенаправление](/redirects). И, конечно же, ничто не мешает Вам перенаправить обратно на страницу, на которой Вы находитесь.

<TabbedCodeExamples
  examples={[
    {
      name: 'Laravel',
      language: 'php',
      code: dedent`
        class UsersController extends Controller
        {
            public function index()
            {
                return Inertia::render('Users/Index', [
                  'users' => User::all(),
                ]);
            }\n
            public function store()
            {
                User::create(
                    Request::validate([
                        'first_name' => ['required', 'max:50'],
                        'last_name' => ['required', 'max:50'],
                        'email' => ['required', 'max:50', 'email'],
                    ])
                );\n
                return Redirect::route('users');
            }
        }
      `,
    },
    {
      name: 'Rails',
      language: 'ruby',
      code: dedent`
        class UsersController < ApplicationController
          def index
            render inertia: 'Users/Index', props: { users: User.all }
          end\n
          def create
            User.create params.require(:user).permit(:first_name, :last_name, :email)\n
            redirect_to users_path
          end
        end
      `,
    },
  ]}
/>

## Загрузка файлов

Уловка для загрузки файлов с помощью Inertia заключается в использовании объекта `FormData`, так как это то, что требуется для отправки запроса `multipart/form-data` через XHR. Вот простой пример использования `FormData` c Inertia.

```js
var data = new FormData()
data.append('name', name || '')
data.append('email', email || '')
data.append('password', password || '')
data.append('is_admin', is_admin ? '1' : '0')
data.append('photo', photo || '')

Inertia.post('/users', data)
```

Однако, начиная с версии `0.8.0`, Inertia автоматически определяет, включает ли посещение какие-либо файлы (даже вложенные файлы), а затем при необходимости преобразует данные в объект `FormData`.

Вы можете узнать больше об интерфейсе `FormData` [здесь](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

## Помощник формы

Поскольку работа с формами настолько распространена, Inertia поставляется с помощником формы, который помогает сократить количество шаблонов, необходимых для типичных форм. Вот как им пользоваться:

<TabbedCodeExamples
  examples={[
    {
      name: 'Vue.js',
      language: 'twig',
      code: dedent`
        <template>
          <form @submit.prevent="form.post('/login')">
            <!-- email -->
            <input type="text" v-model="form.email">
            <div v-if="form.errors.email">{{ form.errors.email }}</div>
            <!-- password -->
            <input type="password" v-model="form.password">
            <div v-if="form.errors.password">{{ form.errors.password }}</div>
            <!-- remember me -->
            <input type="checkbox" v-model="form.remember"> Remember Me
            <!-- submit -->
            <button type="submit" :disabled="form.processing">Login</button>
          </form>
        </template>\n
        <script>
        /*
        |----------------------------------------------------------------
        | Vue 3
        |----------------------------------------------------------------
        */\n
        import { useForm } from '@inertiajs/inertia-vue3'\n
        export default {
          setup () {
            const form = useForm({
              email: null,
              password: null,
              remember: false,
            })\n
            return { form }
          },
        }\n
        /*
        |----------------------------------------------------------------
        | Vue 2
        |----------------------------------------------------------------
        */\n
        export default {
          data() {
            return {
              form: this.$inertia.form({
                email: null,
                password: null,
                remember: false,
              }),
            }
          },
        }
        </script>
      `,
    },
    {
      name: 'React',
      language: 'jsx',
      code: dedent`
        # todo
      `,
    },
    {
      name: 'Svelte',
      language: 'html',
      code: dedent`
        # todo
      `,
    },
  ]}
/>

Если Вам нужно изменить данные формы перед их отправкой на сервер, Вы можете сделать это с помощью метода `transform()`.

```js
this.form
  .transform((data) => ({
    ...data,
    remember: data.remember ? 'on' : '',
  }))
  .post('/login')
```

Вы можете использовать свойство `form.processing`, чтобы отслеживать, отправляется ли форма в данный момент. Это может быть полезно для предотвращения двойной отправки формы, отключив кнопку отправки.

```jsx
<button type="submit" :disabled="form.processing">Submit</button>
```

В случае, если Вы загружаете файлы, текущее событие выполнения доступно через свойство `form.progress`. Это полезно для отображения прогресса загрузки. Например:

```jsx
<progress v-if="form.progress" :value="form.progress.percentage" max="100">
  {{ form.progress.percentage }}%
</progress>
```

В случае ошибок формы они доступны через свойство `form.errors`.

```jsx
<div v-if="form.errors.email">{{ form.errors.email }}</div>
```

Чтобы проверить, нет ли в форме ошибок, используйте свойство `form.hasErrors`. Чтобы удалить ошибки формы, используйте метод `form.clearErrors()`.

```js
// Очистить все ошибки
form.clearErrors()

// Очистить ошибки для определенных полей
form.clearErrors('field', 'anotherfield')
```

Когда форма была успешно отправлена, свойство `form.wasSuccessful` будет иметь значение `true`. В дополнение к этому, существует также свойство `form.recentlySuccessful`, которому будет присвоено значение `true` в течение двух секунд после успешной отправки формы. Это полезно для отображения временных сообщений об успехе.

Чтобы восстановить исходные значения формы, используйте метод `form.reset()`. Обратите внимание, это сбросит значения обратно к начальным значениям, которые были предоставлены, когда Вы вызывали `Inertia.form()`.

```js
// Сбросить форму
form.reset()

// Сбросить определенные поля
form.reset('field', 'anotherfield')
```

## Проверка на стороне сервера

Обработка ошибок проверки на стороне сервера в Inertia работает немного иначе, чем в классической форме, управляемой ajax, где Вы отлавливаете ошибки проверки из ответов `422` и вручную обновляете состояние ошибки формы. Это потому, что Inertia никогда не получает ответов `422`. Скорее, Inertia работает больше как стандартная отправка полностраничной формы. Смотрите [страницу проверки](/validation) для получения дополнительной информации.

## Классическая отправка XHR

Использование Inertia для отправки форм хорошо работает в подавляющем большинстве ситуаций. Однако, если Вам нужен более точный контроль над отправкой формы, ничто не мешает Вам сделать классический запрос XHR. Отличная библиотека для использования здесь [axios](https://github.com/axios/axios), которую Inertia использует под капотом.
