import dedent from 'dedent-js'
import Layout from '../components/Layout'
import TabbedCodeExamples from '../components/TabbedCodeExamples'

export default Layout
export const meta = {
  title: 'Формы',
  links: [
    { url: '#отправка-форм', name: 'Отправка форм' },
    { url: '#проверка-на-стороне-сервера', name: 'Проверка на стороне сервера' },
    { url: '#загрузка-файлов', name: 'Загрузка файлов' },
    { url: '#классическая-отправка-xhr', name: 'Классическая отправка XHR' },
  ],
}

# Формы

## Отправка форм

Хотя с помощью Inertia можно отправлять классические формы, это не рекомендуется, так как они вызывают полную перезагрузку страницы. Вместо этого лучше перехватить отправленные формы, а затем сделать [запрос](/requests) с помощью Inertia.

<TabbedCodeExamples
  examples={[
    {
      name: 'Vue.js',
      language: 'twig',
      code: dedent`
        <template>
          <form @submit.prevent="submit">
            <label for="first_name">First name:</label>
            <input id="first_name" v-model="form.first_name" />
            <label for="last_name">Last name:</label>
            <input id="last_name" v-model="form.last_name" />
            <label for="email">Email:</label>
            <input id="email" v-model="form.email" />
            <button type="submit">Submit</button>
          </form>
        </template>\n
        <script>
        export default {
          data() {
            return {
              form: {
                first_name: null,
                last_name: null,
                email: null,
              },
            }
          },
          methods: {
            submit() {
              this.$inertia.post('/users', this.form)
            },
          },
        }
        </script>
      `,
    },
    {
      name: 'React',
      language: 'jsx',
      code: dedent`
        import { Inertia } from '@inertiajs/inertia'
        import React, { useState } from 'react'\n
        export default function Edit() {
          const [values, setValues] = useState({
            first_name: "",
            last_name: "",
            email: "",
          })\n
          function handleChange(e) {
            const key = e.target.id;
            const value = e.target.value
            setValues(values => ({
                ...values,
                [key]: value,
            }))
          }\n
          function handleSubmit(e) {
            e.preventDefault()
            Inertia.post('/users', values)
          }\n
          return (
            <form onSubmit={handleSubmit}>
              <label htmlFor="first_name">First name:</label>
              <input id="first_name" value={values.first_name} onChange={handleChange} />
              <label htmlFor="last_name">Last name:</label>
              <input id="last_name" value={values.last_name} onChange={handleChange} />
              <label htmlFor="email">Email:</label>
              <input id="email" value={values.email} onChange={handleChange} />
              <button type="submit">Submit</button>
            </form>
          )
        }
      `,
    },
    {
      name: 'Svelte',
      language: 'html',
      code: dedent`
        <script>
          import { Inertia } from '@inertiajs/inertia'\n
          let values = {
            first_name: null,
            last_name: null,
            email: null,
          }\n
          function handleSubmit() {
            Inertia.post('/users', values)
          }
        </script>\n
        <form on:submit|preventDefault={handleSubmit}>
          <label for="first_name">First name:</label>
          <input id="first_name" bind:value={values.first_name}>\n
          <label for="last_name">Last name:</label>
          <input id="last_name" bind:value={values.last_name}>\n
          <label for="email">Email:</label>
          <input id="email" bind:value={values.email}>\n
          <button type="submit">Submit</button>
        </form>
      `,
    },
  ]}
/>

В отличие от классической формы отправки ajax, с помощью Inertia Вы не обрабатываете поведение отправки сообщения на стороне клиента. Скорее, Вы делаете это на стороне сервера, используя [перенаправление](/redirects). И, конечно же, ничто не мешает Вам перенаправить обратно на страницу, на которой Вы находитесь.

<TabbedCodeExamples
  examples={[
    {
      name: 'Laravel',
      language: 'php',
      code: dedent`
        class UsersController extends Controller
        {
            public function index()
            {
                return Inertia::render('Users/Index', [
                  'users' => User::all(),
                ]);
            }\n
            public function store()
            {
                User::create(
                    Request::validate([
                        'first_name' => ['required', 'max:50'],
                        'last_name' => ['required', 'max:50'],
                        'email' => ['required', 'max:50', 'email'],
                    ])
                );\n
                return Redirect::route('users');
            }
        }
      `,
    },
    {
      name: 'Rails',
      language: 'ruby',
      code: dedent`
        class UsersController < ApplicationController
          def index
            render inertia: 'Users/Index', props: { users: User.all }
          end\n
          def create
            User.create params.require(:user).permit(:first_name, :last_name, :email)\n
            redirect_to users_path
          end
        end
      `,
    },
  ]}
/>

## Проверка на стороне сервера

Обработка ошибок проверки на стороне сервера (ответы `422`) в Inertia работает немного иначе, чем классическая форма, управляемая ajax, где Вы обнаруживаете ошибки проверки в ответе, а затем обновляете состояние формы. Хитрость заключается в том, чтобы обрабатывать ошибки валидации, как в серверной структуре.

Сначала Вы отправляете форму с помощью Inertia. Если есть ошибки проверки, Вы перенаправляете серверную часть обратно на страницу формы, включая ошибки в сеансе. Ваша серверная инфраструктура, вероятно, уже делает это автоматически.

Оттуда Вам нужно отправить эти сообщения об ошибках в компонент страницы формы. Вы можете сделать это в своем контроллере, но лучше просто сделать это автоматически для всех компонентов Вашей страницы. Для этого Вы можете использовать функцию Inertia [общие](/shared-data).

Некоторые адаптеры, такие как адаптер Laravel (начиная с [v0.2.9](https://github.com/inertiajs/inertia-laravel/releases/tag/v0.2.9)), делают это автоматически, делая доступными ошибки проверки через свойство `errors`. Однако, если Вы хотите поделиться ими вручную (возможно, Вам нужны ошибки в другом формате), Вы все равно можете сделать это:

<TabbedCodeExamples
  examples={[
    {
      name: 'Laravel',
      language: 'php',
      code: dedent`
        class HandleInertiaRequests extends Middleware
        {
            public function share(Request $request)
            {
                return array_merge(parent::share($request), [
                    'errors' => fn () => $request->session()->get('errors')
                        ? $request->session()->get('errors')->getBag('default')->getMessages()
                        : (object) []
                ]);
            }
        }
      `,
    },
    {
      name: 'Rails',
      language: 'ruby',
      code: dedent`
        # todo
      `,
    },
  ]}
/>

Теперь ошибки проверки будут доступны как часть свойств Вашей страницы, и, поскольку они являются реактивными, Ваш шаблон автоматически отобразит их. Вот обновленная версия приведенного выше примера формы, в которой отображаются ошибки проверки на стороне сервера.

<TabbedCodeExamples
  examples={[
    {
      name: 'Vue.js',
      language: 'twig',
      code: dedent`
        <template>
          <form @submit.prevent="submit">
            <label for="first_name">First name:</label>
            <input id="first_name" v-model="form.first_name" />
            <div v-if="errors.first_name">{{ errors.first_name[0] }}</div>
            <label for="last_name">Last name:</label>
            <input id="last_name" v-model="form.last_name" />
            <div v-if="errors.last_name">{{ errors.last_name[0] }}</div>
            <label for="email">Email:</label>
            <input id="email" v-model="form.email" />
            <div v-if="errors.email">{{ errors.email[0] }}</div>
            <button type="submit">Submit</button>
          </form>
        </template>\n
        <script>
        export default {
          props: {
            errors: Object,
          },
          data() {
            return {
              form: {
                first_name: null,
                last_name: null,
                email: null,
              },
            }
          },
          methods: {
            submit() {
              this.$inertia.post('/users', this.form)
            },
          },
        }
        </script>
      `,
    },
    {
      name: 'React',
      language: 'jsx',
      code: dedent`
        import { Inertia } from '@inertiajs/inertia'
        import { usePage } from '@inertiajs/inertia-react'
        import React, { useState } from 'react'\n
        export default function Edit() {
          const { errors } = usePage().props\n
          const [values, setValues] = useState({
            first_name: null,
            last_name: null,
            email: null,
          })\n
          function handleChange(e) {
            setValues(values => ({
              ...values,
              [e.target.id]: e.target.value,
            }))
          }\n
          function handleSubmit(e) {
            e.preventDefault()
            Inertia.post('/users', values)
          }\n
          return (
            <form onSubmit={handleSubmit}>
              <label for="first_name">First name:</label>
              <input id="first_name" value={values.first_name} onChange={handleChange} />
              {errors.first_name && <div>{errors.first_name[0]}</div>}
              <label for="last_name">Last name:</label>
              <input id="last_name" value={values.last_name} onChange={handleChange} />
              {errors.last_name && <div>{errors.last_name[0]}</div>}
              <label for="email">Email:</label>
              <input id="email" value={values.email} onChange={handleChange} />
              {errors.email && <div>{errors.email[0]}</div>}
              <button type="submit">Submit</button>
            </form>
          )
        }
      `,
    },
    {
      name: 'Svelte',
      language: 'html',
      code: dedent`
        <script>
          import { Inertia } from '@inertiajs/inertia'\n
          export let errors = {}\n
          let values = {
            first_name: null,
            last_name: null,
            email: null,
          }\n
          function handleSubmit() {
            Inertia.post('/users', values)
          }
        </script>\n
        <form on:submit|preventDefault={handleSubmit}>
          <label for="first_name">First name:</label>
          <input id="first_name" bind:value={values.first_name}>
          {#if errors.first_name}<div>{errors.first_name}</div>{/if}\n
          <label for="last_name">Last name:</label>
          <input id="last_name" bind:value={values.last_name}>
          {#if errors.last_name}<div>{errors.last_name}</div>{/if}\n
          <label for="email">Email:</label>
          <input id="email" bind:value={values.email}>
          {#if errors.email}<div>{errors.email}</div>{/if}\n
          <button type="submit">Submit</button>
        </form>
      `,
    },
  ]}
/>

Хотя это очень похоже на то, как Вы обычно выполняете классическую отправку форм на стороне сервера, этот подход намного лучше, поскольку Вы не перезагружаете всю страницу и не обновляете входные данные формы.

## Загрузка файлов

Уловка для загрузки файлов с помощью Inertia (через XHR) заключается в использовании объекта `FormData`. Вот простой пример использования `FormData` с Inertia.

```js
var data = new FormData()
data.append('first_name', first_name || '')
data.append('last_name', last_name || '')
data.append('email', email || '')
data.append('password', password || '')
data.append('photo', photo || '')

Inertia.post('/users', data)
```

Вы можете узнать больше об интерфейсе `FormData` [здесь](https://developer.mozilla.org/en-US/docs/Web/API/FormData).

## Классическая отправка XHR

Использование Inertia для отправки форм хорошо работает в подавляющем большинстве ситуаций. Однако, если Вам нужен более точный контроль над отправкой формы, ничто не мешает Вам сделать классический запрос XHR. Отличная библиотека для использования здесь [axios](https://github.com/axios/axios), которую Inertia использует под капотом.
